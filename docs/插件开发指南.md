# URLDB æ’ä»¶å¼€å‘æŒ‡å—

## ğŸ“‹ ç›®å½•

1. [å¼€å‘ç¯å¢ƒæ­å»º](#å¼€å‘ç¯å¢ƒæ­å»º)
2. [æ’ä»¶åŸºç¡€ç»“æ„](#æ’ä»¶åŸºç¡€ç»“æ„)
3. [JavaScript/TypeScriptå¼€å‘](#javascripttypescriptå¼€å‘)
4. [æ•°æ®åº“æ“ä½œ](#æ•°æ®åº“æ“ä½œ)
5. [APIå¼€å‘](#apiå¼€å‘)
6. [æµ‹è¯•å’Œè°ƒè¯•](#æµ‹è¯•å’Œè°ƒè¯•)
7. [éƒ¨ç½²å’Œå‘å¸ƒ](#éƒ¨ç½²å’Œå‘å¸ƒ)
8. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒæ­å»º

### å¿…éœ€å·¥å…·

1. **Go 1.24+** - ç”¨äºç¼–è¯‘å’Œè¿è¡ŒURLDB
2. **Node.js 16+** - ç”¨äºTypeScriptå¼€å‘ï¼ˆå¯é€‰ï¼‰
3. **VS Code** - æ¨èIDEï¼Œé…åˆæ’ä»¶å¼€å‘
4. **PostgreSQLå®¢æˆ·ç«¯** - æ•°æ®åº“ç®¡ç†

### VS Code æ¨èæ’ä»¶

```json
// .vscode/extensions.json
{
    "recommendations": [
        "ms-vscode.vscode-typescript-next",
        "bradlc.vscode-tailwindcss",
        "esbenp.prettier-vscode",
        "ms-vscode.vscode-json",
        "golang.go"
    ]
}
```

### é¡¹ç›®é…ç½®

```json
// package.json (TypeScriptå¼€å‘)
{
    "name": "urldb-plugins",
    "version": "1.0.0",
    "scripts": {
        "build": "tsc",
        "watch": "tsc --watch",
        "validate": "node scripts/validate.js",
        "test": "jest"
    },
    "devDependencies": {
        "@types/node": "^20.0.0",
        "typescript": "^5.0.0",
        "jest": "^29.0.0",
        "@types/jest": "^29.0.0"
    }
}
```

```json
// tsconfig.json
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": ["ES2020"],
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true
    },
    "include": [
        "src/**/*",
        "pb_data/types.d.ts"
    ],
    "exclude": [
        "node_modules",
        "dist"
    ]
}
```

---

## ğŸ—ï¸ æ’ä»¶åŸºç¡€ç»“æ„

### æ’ä»¶ç±»å‹

URLDBæ”¯æŒä¸¤ç§ç±»å‹çš„æ’ä»¶ï¼š

1. **é’©å­æ’ä»¶ (Hook Plugins)** - å“åº”ç³»ç»Ÿäº‹ä»¶
2. **å‹ç¼©åŒ…æ’ä»¶ (Package Plugins)** - åŒ…å«å®Œæ•´åŠŸèƒ½æ¨¡å—

---

## ğŸ”„ æ•°æ®åº“è¿ç§» (migrate) åŠŸèƒ½

### è¿ç§»åŠŸèƒ½æ¦‚è¿°

ä» v2.0.0 ç‰ˆæœ¬å¼€å§‹ï¼ŒURLDB å¯¹ migrate åŠŸèƒ½è¿›è¡Œäº†é‡è¦ä¼˜åŒ–ï¼š

- âŒ **Hook ç±»å‹æ’ä»¶ä¸å†æ”¯æŒ migrate åŠŸèƒ½**
- âœ… **å‹ç¼©åŒ…æ’ä»¶æ”¯æŒæ•°æ®åº“è¿ç§»**

### è¿ç§»è§„åˆ™è¯´æ˜

#### 1. Hook ç±»å‹æ’ä»¶
- **ä¸æ”¯æŒ migrate å‡½æ•°è°ƒç”¨**
- âŒ ä»¥ä¸‹ä»£ç å°†ä¸å†å·¥ä½œï¼š
  ```javascript
  migrate(
      (app) => {
          // æ•°æ®åº“è¿ç§»é€»è¾‘
      },
      (app) => {
          // å›æ»šé€»è¾‘
      }
  );
  ```
- âœ… **æ›¿ä»£æ–¹æ¡ˆ**ï¼šä½¿ç”¨å‹ç¼©åŒ…æ’ä»¶çš„ SQL è¿ç§»

#### 2. å‹ç¼©åŒ…æ’ä»¶
- **è‡ªåŠ¨æ‰§è¡Œ migrate ç›®å½•ä¸­çš„ SQL æ–‡ä»¶**
- ğŸ“ **ç›®å½•ç»“æ„**ï¼š
  ```
  plugin-package.zip
  â”œâ”€â”€ main.js              # ä¸»æ’ä»¶æ–‡ä»¶
  â”œâ”€â”€ package.json          # æ’ä»¶é…ç½®
  â””â”€â”€ migrate/             # è¿ç§»ç›®å½•
  â”‚   â”œâ”€â”€ install.sql      # å®‰è£…æ—¶æ‰§è¡Œ
  â”‚   â””â”€â”€ uninstall.sql    # å¸è½½æ—¶æ‰§è¡Œ
  â””â”€â”€ hooks/               # é’©å­æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
  â”‚   â””â”€â”€ main.js
  â”‚   â””â”€â”€ config.js
  ```

### SQL è¿ç§»æ–‡ä»¶è§„èŒƒ

#### install.sql æ–‡ä»¶
```sql
-- æ’ä»¶å®‰è£…è¿ç§»è„šæœ¬
-- åˆ›å»ºæ—¶é—´: 2025-12-30

-- åˆ›å»ºæ•°æ®è¡¨
CREATE TABLE IF NOT EXISTS plugin_migration_test (
    id SERIAL PRIMARY KEY,
    plugin_name VARCHAR(100) NOT NULL,
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ’å…¥åˆå§‹æ•°æ®
INSERT INTO plugin_migration_test (plugin_name, message)
VALUES ('your_plugin_name', 'æ’ä»¶å®‰è£…æ—¶åˆ›å»ºçš„æµ‹è¯•æ•°æ®');
```

#### uninstall.sql æ–‡ä»¶
```sql
-- æ’ä»¶å¸è½½è¿ç§»è„šæœ¬
-- åˆ›å»ºæ—¶é—´: 2025-12-30

-- åˆ é™¤æ•°æ®è¡¨
DROP TABLE IF EXISTS plugin_migration_test;
```

### è¿ç§»æ‰§è¡Œæ—¶æœº

1. **å®‰è£…æ—¶**ï¼šæ’ä»¶å®‰è£…å®Œæˆåè‡ªåŠ¨æ‰§è¡Œ `migrate/install.sql`
2. **å¸è½½æ—¶**ï¼šæ’ä»¶åˆ é™¤å‰è‡ªåŠ¨æ‰§è¡Œ `migrate/uninstall.sql`

### è¿ç§»æ—¥å¿—

ç³»ç»Ÿä¼šè¯¦ç»†è®°å½•è¿ç§»æ‰§è¡Œè¿‡ç¨‹ï¼š

```log
2025/12/30 22:48:19 [INFO] Starting install migration execution for plugin: plugins/installed/test_migration_plugin
2025/12/30 22:48:19 [INFO] Checking migration file: plugins/installed/test_migration_plugin/migrate/install.sql
2025/12/30 22:48:19 [INFO] Executing install migration for plugin: plugins/installed/test_migration_plugin
2025/12/30 22:48:19 [INFO] Migration SQL content: -- æµ‹è¯•è¿ç§»æ’ä»¶çš„å®‰è£…è„šæœ¬...
2025/12/30 22:48:19 [INFO] Successfully executed install migration for plugin
```

### é”™è¯¯å¤„ç†

- è¿ç§»å¤±è´¥ä¼šé˜»æ­¢æ’ä»¶å®‰è£…
- è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ä¼šè®°å½•åˆ°æ—¥å¿—
- æ”¯æŒäº‹åŠ¡å›æ»šæœºåˆ¶

### æœ€ä½³å®è·µ

1. **SQL æ–‡ä»¶å‘½å**ï¼šä½¿ç”¨æè¿°æ€§çš„æ–‡ä»¶å
2. **æ•°æ®è¡¨å‘½å**ï¼šåŒ…å«æ’ä»¶å‰ç¼€é¿å…å†²çª
3. **ç‰ˆæœ¬å…¼å®¹**ï¼šæ”¯æŒæ•°æ®åº“ç»“æ„ç‰ˆæœ¬å‡çº§
4. **æµ‹è¯•æ•°æ®**ï¼šæä¾›æœ‰æ„ä¹‰çš„æµ‹è¯•æ•°æ®
5. **æ¸…ç†æœºåˆ¶**ï¼šç¡®ä¿å¸è½½æ—¶å®Œæ•´æ¸…ç†

### ç¤ºä¾‹ï¼šå®Œæ•´çš„è¿ç§»æ’ä»¶

åˆ›å»ºä¸€ä¸ªåŒ…å«æ•°æ®åº“è¿ç§»åŠŸèƒ½çš„å‹ç¼©åŒ…æ’ä»¶ï¼š

```javascript
// main.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * æ•°æ®åº“è¿ç§»ç¤ºä¾‹æ’ä»¶
 * åˆ›å»ºæ—¶é—´: 2025-12-30
 */

console.log("æ•°æ®åº“è¿ç§»æ’ä»¶å·²åŠ è½½");

// æ·»åŠ APIè·¯ç”±ç”¨äºæµ‹è¯•
routerAdd('GET', '/api/migration-status', (e) => {
    try {
        const result = app.db.queryOne(`
            SELECT COUNT(*) as count
            FROM plugin_migration_test
        `);

        return e.json(200, {
            success: true,
            message: "è¿ç§»çŠ¶æ€æ£€æŸ¥æˆåŠŸ",
            data: {
                table_exists: result.count > 0,
                record_count: result.count,
                plugin: "database_migration_plugin"
            }
        });
    } catch (error) {
        return e.json(500, {
            success: false,
            error: error.message
        });
    }
});
```

```json
// package.json
{
  "name": "database_migration_plugin",
  "version": "1.0.0",
  "description": "æ•°æ®åº“è¿ç§»ç¤ºä¾‹æ’ä»¶",
  "author": "URLDBå¼€å‘å›¢é˜Ÿ",
  "main": "main.js",
  "hooks": ["main.js"],
  "config": {
      "enabled": true
  }
}
```

```sql
// migrate/install.sql
-- æ•°æ®åº“è¿ç§»å®‰è£…è„šæœ¬
-- åˆ›å»ºç”¨æˆ·æ‰©å±•è¡¨

CREATE TABLE IF NOT EXISTS user_extensions (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    extension_type VARCHAR(50) NOT NULL,
    extension_data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_user_extensions_user_id
ON user_extensions(user_id);

-- æ’å…¥é»˜è®¤é…ç½®
INSERT INTO user_extensions (user_id, extension_type, extension_data)
SELECT
    id as user_id,
    'theme' as extension_type,
    '{"theme": "light", "language": "zh-CN"}' as extension_data;
```

```sql
// migrate/uninstall.sql
-- æ•°æ®åº“è¿ç§»å¸è½½è„šæœ¬

-- åˆ é™¤æ‰©å±•è¡¨
DROP TABLE IF EXISTS user_extensions;
```

é€šè¿‡éµå¾ªè¿™äº› migrate è§„åˆ™ï¼Œå¼€å‘è€…å¯ä»¥å®‰å…¨åœ°ä¸ºå‹ç¼©åŒ…æ’ä»¶æ·»åŠ æ•°æ®åº“è¿ç§»åŠŸèƒ½ã€‚

### é’©å­æ’ä»¶ç»“æ„

```javascript
/// <reference path="../pb_data/types.d.ts" />

/**
 * æ’ä»¶åç§°å’Œæè¿°
 * ä½œè€…: Your Name
 * ç‰ˆæœ¬: 1.0.0
 * åˆ›å»ºæ—¶é—´: 2024-12-24
 */

// æ’ä»¶é…ç½®
const PLUGIN_CONFIG = {
    name: "example-plugin",
    version: "1.0.0",
    enabled: true,
    debug: false
};

// æ’ä»¶åˆå§‹åŒ–
function initialize() {
    console.log(`[${PLUGIN_CONFIG.name}] æ’ä»¶åˆå§‹åŒ–å¼€å§‹`);

    // æ’ä»¶åˆå§‹åŒ–é€»è¾‘
    checkDependencies();
    setupDefaults();

    console.log(`[${PLUGIN_CONFIG.name}] æ’ä»¶åˆå§‹åŒ–å®Œæˆ`);
}

// æ£€æŸ¥ä¾èµ–
function checkDependencies() {
    // æ£€æŸ¥å¿…éœ€çš„æ•°æ®è¡¨æ˜¯å¦å­˜åœ¨
    const tables = app.db.query(`
        SELECT name FROM sqlite_master
        WHERE type='table' AND name IN ('users', 'urls')
    `);

    if (tables.length < 2) {
        throw new Error("ç¼ºå°‘å¿…éœ€çš„æ•°æ®è¡¨: users, urls");
    }
}

// è®¾ç½®é»˜è®¤å€¼
function setupDefaults() {
    const configExists = app.db.queryOne(`
        SELECT COUNT(*) as count FROM system_config
        WHERE key = 'plugin.example.enabled'
    `).count > 0;

    if (!configExists) {
        app.db.execute(`
            INSERT INTO system_config (key, value, type)
            VALUES ('plugin.example.enabled', 'true', 'boolean')
        `);
    }
}

// äº‹ä»¶å¤„ç†å™¨
onURLAdd((e) => {
    if (!PLUGIN_CONFIG.enabled) {
        return e.next();
    }

    try {
        processURL(e);
        return e.next();
    } catch (error) {
        console.error(`[${PLUGIN_CONFIG.name}] URLå¤„ç†å¤±è´¥:`, error);
        return e.next();
    }
});

// æ ¸å¿ƒå¤„ç†é€»è¾‘
function processURL(e) {
    console.log(`[${PLUGIN_CONFIG.name}] å¤„ç†URL:`, e.url.url);

    // URLåˆ†ç±»é€»è¾‘
    categorizeURL(e);

    // æ ‡ç­¾æå–
    extractTags(e);

    // å…ƒæ•°æ®ä¸°å¯Œ
    enrichMetadata(e);

    console.log(`[${PLUGIN_CONFIG.name}] URLå¤„ç†å®Œæˆ`);
}

// URLåˆ†ç±»
function categorizeURL(e) {
    const url = e.url.url;
    let category = "uncategorized";

    if (url.includes("github.com")) {
        category = "development";
    } else if (url.includes("youtube.com") || url.includes("bilibili.com")) {
        category = "video";
    } else if (url.includes("stackoverflow.com")) {
        category = "qa";
    } else if (url.includes("medium.com") || url.includes("dev.to")) {
        category = "blog";
    }

    e.url.category = category;
}

// æ ‡ç­¾æå–
function extractTags(e) {
    const url = e.url.url;
    const tags = e.url.tags || [];

    // åŸŸåæ ‡ç­¾
    const domain = new URL(url).hostname;
    tags.push(domain.replace("www.", ""));

    // è·¯å¾„æ ‡ç­¾
    const path = new URL(url).pathname;
    if (path.includes("/docs")) tags.push("documentation");
    if (path.includes("/tutorial")) tags.push("tutorial");
    if (path.includes("/api")) tags.push("api");

    e.url.tags = [...new Set(tags)]; // å»é‡
}

// å…ƒæ•°æ®ä¸°å¯Œ
function enrichMetadata(e) {
    if (!e.url.title) {
        e.url.title = extractTitleFromURL(e.url.url);
    }

    if (!e.url.description) {
        e.url.description = `ä» ${e.url.url} æå–çš„å†…å®¹`;
    }

    e.url.enriched_at = new Date().toISOString();
}

// å·¥å…·å‡½æ•°
function extractTitleFromURL(url) {
    try {
        const urlObj = new URL(url);
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        return pathParts[pathParts.length - 1] || urlObj.hostname;
    } catch {
        return url;
    }
}

// æ’ä»¶æ¸…ç†ï¼ˆå¯é€‰ï¼‰
function cleanup() {
    console.log(`[${PLUGIN_CONFIG.name}] æ’ä»¶æ¸…ç†å®Œæˆ`);
}

// åˆå§‹åŒ–æ’ä»¶
initialize();
```

### è¿ç§»æ’ä»¶ç»“æ„

```javascript
/**
 * æ•°æ®åº“è¿ç§»æ’ä»¶
 * åˆ›å»ºæ—¶é—´: 2024-12-24
 * æè¿°: æ·»åŠ ç”¨æˆ·åå¥½è®¾ç½®è¡¨
 */

migrate(
    // up è¿ç§»
    (app) => {
        console.log("æ‰§è¡Œå‘ä¸Šè¿ç§»: add_user_preferences");

        // åˆ›å»ºç”¨æˆ·åå¥½è®¾ç½®è¡¨
        const createTable = `
            CREATE TABLE IF NOT EXISTS user_preferences (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                theme TEXT DEFAULT 'light',
                language TEXT DEFAULT 'zh-CN',
                notifications BOOLEAN DEFAULT true,
                email_notifications BOOLEAN DEFAULT true,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            )
        `;

        app.db.run(createTable);

        // åˆ›å»ºç´¢å¼•
        app.db.run(`
            CREATE INDEX IF NOT EXISTS idx_user_preferences_user_id
            ON user_preferences(user_id)
        `);

        // ä¸ºç°æœ‰ç”¨æˆ·åˆ›å»ºé»˜è®¤åå¥½è®¾ç½®
        const users = app.db.query("SELECT id FROM users");
        users.forEach(user => {
            app.db.run(`
                INSERT OR IGNORE INTO user_preferences (id, user_id)
                VALUES (?, ?)
            `, [generateUUID(), user.id]);
        });

        console.log("ç”¨æˆ·åå¥½è®¾ç½®è¡¨åˆ›å»ºå®Œæˆ");
    },

    // down å›æ»š
    (app) => {
        console.log("æ‰§è¡Œå›æ»šè¿ç§»: add_user_preferences");

        // åˆ é™¤è¡¨
        app.db.run("DROP TABLE IF EXISTS user_preferences");

        console.log("ç”¨æˆ·åå¥½è®¾ç½®è¡¨åˆ é™¤å®Œæˆ");
    }
);

// UUIDç”Ÿæˆå·¥å…·å‡½æ•°
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
```

---

## ğŸ’» JavaScript/TypeScriptå¼€å‘

### TypeScriptç±»å‹å®šä¹‰

```typescript
// src/types/urldb.d.ts
declare global {
    interface App {
        db: Database;
        config: Config;
        mail: Mailer;
        triggerCustom(event: string, data: any): void;
    }

    interface Database {
        query(sql: string, ...params: any[]): any[];
        queryOne(sql: string, ...params: any[]): any;
        execute(sql: string, ...params: any[]): { lastInsertRowid: number };
        transaction(fn: (tx: Transaction) => any): any;
    }

    interface Config {
        get(key: string, defaultValue?: any): any;
        getString(key: string, defaultValue?: string): string;
        getBool(key: string, defaultValue?: boolean): boolean;
        getInt(key: string, defaultValue?: number): number;
    }

    interface Mailer {
        send(options: MailOptions): void;
    }

    interface MailOptions {
        to: string;
        subject: string;
        body: string;
        html?: string;
    }

    interface URLEvent {
        url: {
            id: string;
            url: string;
            title?: string;
            description?: string;
            category?: string;
            tags?: string[];
        };
        user?: {
            id: string;
            username: string;
            email: string;
        };
        data: Record<string, any>;
        next(): Promise<void>;
    }

    interface UserEvent {
        user: {
            id: string;
            username: string;
            email: string;
            role?: string;
        };
        data: Record<string, any>;
        next(): Promise<void>;
    }
}

declare function onURLAdd(handler: (e: URLEvent) => Promise<void>): void;
declare function onUserLogin(handler: (e: UserEvent) => Promise<void>): void;
declare function routerAdd(method: string, path: string, handler: (e: any) => any): void;
declare function cronAdd(name: string, schedule: string, handler: () => void): void;

export {};
```

### TypeScriptæ’ä»¶ç¤ºä¾‹

```typescript
// src/plugins/analyzer-plugin.ts
/// <reference path="../../pb_data/types.d.ts" />

interface PluginConfig {
    enabled: boolean;
    categories: Record<string, string[]>;
    debug: boolean;
}

interface URLAnalysis {
    category: string;
    tags: string[];
    confidence: number;
    metadata: Record<string, any>;
}

class URLAnalyzer {
    private config: PluginConfig;

    constructor() {
        this.config = this.loadConfig();
        this.initialize();
    }

    private loadConfig(): PluginConfig {
        return {
            enabled: app.config.getBool("analyzer.enabled", true),
            categories: {
                development: ["github.com", "stackoverflow.com", "dev.to"],
                video: ["youtube.com", "bilibili.com", "vimeo.com"],
                social: ["twitter.com", "facebook.com", "linkedin.com"],
                news: ["cnn.com", "bbc.com", "reuters.com"]
            },
            debug: app.config.getBool("analyzer.debug", false)
        };
    }

    private initialize(): void {
        if (this.config.enabled) {
            console.log("[URLAnalyzer] æ’ä»¶å·²å¯ç”¨");
            this.setupEventHandlers();
        } else {
            console.log("[URLAnalyzer] æ’ä»¶å·²ç¦ç”¨");
        }
    }

    private setupEventHandlers(): void {
        onURLAdd(async (e: URLEvent) => {
            if (!this.config.enabled) {
                return e.next();
            }

            try {
                const analysis = this.analyzeURL(e.url.url);
                this.applyAnalysis(e, analysis);

                if (this.config.debug) {
                    console.log("[URLAnalyzer] åˆ†æç»“æœ:", analysis);
                }

                return e.next();
            } catch (error) {
                console.error("[URLAnalyzer] åˆ†æå¤±è´¥:", error);
                return e.next();
            }
        });
    }

    private analyzeURL(url: string): URLAnalysis {
        const urlObj = new URL(url);
        const domain = urlObj.hostname.replace("www.", "");

        // åˆ†ç±»è¯†åˆ«
        const category = this.identifyCategory(domain);

        // æ ‡ç­¾æå–
        const tags = this.extractTags(urlObj, category);

        // ç½®ä¿¡åº¦è®¡ç®—
        const confidence = this.calculateConfidence(domain, category, tags);

        return {
            category,
            tags,
            confidence,
            metadata: {
                domain,
                path: urlObj.pathname,
                protocol: urlObj.protocol,
                analyzed_at: new Date().toISOString()
            }
        };
    }

    private identifyCategory(domain: string): string {
        for (const [category, domains] of Object.entries(this.config.categories)) {
            if (domains.some(d => domain.includes(d))) {
                return category;
            }
        }
        return "uncategorized";
    }

    private extractTags(urlObj: URL, category: string): string[] {
        const tags: string[] = [];

        // åŸŸåæ ‡ç­¾
        tags.push(urlObj.hostname.replace("www.", ""));

        // è·¯å¾„æ ‡ç­¾
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        pathParts.forEach(part => {
            if (part.length > 2 && part.length < 20) {
                tags.push(part);
            }
        });

        // åˆ†ç±»ç‰¹å®šæ ‡ç­¾
        switch (category) {
            case "development":
                if (urlObj.pathname.includes("/docs")) tags.push("documentation");
                if (urlObj.pathname.includes("/issues")) tags.push("issues");
                if (urlObj.pathname.includes("/pull")) tags.push("pull-requests");
                break;
            case "video":
                if (urlObj.searchParams.has("list")) tags.push("playlist");
                if (urlObj.searchParams.has("t")) tags.push("timestamp");
                break;
        }

        return [...new Set(tags)];
    }

    private calculateConfidence(domain: string, category: string, tags: string[]): number {
        let confidence = 0.5; // åŸºç¡€ç½®ä¿¡åº¦

        // åŸŸååŒ¹é…åŠ åˆ†
        if (this.config.categories[category]?.includes(domain)) {
            confidence += 0.3;
        }

        // æ ‡ç­¾æ•°é‡åŠ åˆ†
        confidence += Math.min(tags.length * 0.05, 0.2);

        return Math.min(confidence, 1.0);
    }

    private applyAnalysis(e: URLEvent, analysis: URLAnalysis): void {
        e.url.category = analysis.category;
        e.url.tags = analysis.tags;

        // ä¿å­˜åˆ†æç»“æœ
        app.db.execute(`
            INSERT INTO url_analysis (url_id, category, tags, confidence, metadata, created_at)
            VALUES (?, ?, ?, ?, ?, datetime('now'))
        `, [
            e.url.id,
            analysis.category,
            JSON.stringify(analysis.tags),
            analysis.confidence,
            JSON.stringify(analysis.metadata)
        ]);
    }
}

// åˆå§‹åŒ–æ’ä»¶
new URLAnalyzer();
```

### é«˜çº§JavaScriptæ¨¡å¼

```javascript
// hooks/advanced-plugin.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * é«˜çº§æ’ä»¶æ¨¡å¼ç¤ºä¾‹
 * å±•ç¤ºæ¨¡å—åŒ–ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–ç­‰
 */

// æ¨¡å—åŒ–æ’ä»¶ç³»ç»Ÿ
const PluginSystem = (function() {
    'use strict';

    // æ’ä»¶åŸºç±»
    class BasePlugin {
        constructor(name, version = '1.0.0') {
            this.name = name;
            this.version = version;
            this.enabled = true;
            this.config = {};
            this.stats = {
                executions: 0,
                errors: 0,
                totalTime: 0
            };
        }

        // åˆå§‹åŒ–
        async initialize() {
            console.log(`[${this.name}] åˆå§‹åŒ–å¼€å§‹`);
            await this.loadConfig();
            await this.setupDatabase();
            await this.registerHandlers();
            console.log(`[${this.name}] åˆå§‹åŒ–å®Œæˆ`);
        }

        // åŠ è½½é…ç½®
        async loadConfig() {
            const configKeys = [
                `${this.name}.enabled`,
                `${this.name}.debug`,
                `${this.name}.batch_size`
            ];

            for (const key of configKeys) {
                const configKey = `plugin.${key}`;
                this.config[key.replace(`${this.name}.`, '')] = app.config.get(configKey);
            }
        }

        // æ•°æ®åº“è®¾ç½®
        async setupDatabase() {
            const tableName = `${this.name}_data`;

            app.db.execute(`
                CREATE TABLE IF NOT EXISTS ${tableName} (
                    id TEXT PRIMARY KEY,
                    plugin_name TEXT,
                    data JSON,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        }

        // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
        async registerHandlers() {
            // å­ç±»å®ç°
        }

        // æ€§èƒ½ç›‘æ§è£…é¥°å™¨
        withStats(handlerName, handler) {
            return async (...args) => {
                const startTime = Date.now();
                this.stats.executions++;

                try {
                    const result = await handler.apply(this, args);

                    if (this.config.debug) {
                        console.log(`[${this.name}] ${handlerName} æ‰§è¡ŒæˆåŠŸ`);
                    }

                    return result;
                } catch (error) {
                    this.stats.errors++;
                    console.error(`[${this.name}] ${handlerName} æ‰§è¡Œå¤±è´¥:`, error);
                    throw error;
                } finally {
                    this.stats.totalTime += Date.now() - startTime;
                }
            };
        }

        // æ‰¹å¤„ç†å·¥å…·
        async batchProcess(items, processor, batchSize = 100) {
            const results = [];

            for (let i = 0; i < items.length; i += batchSize) {
                const batch = items.slice(i, i + batchSize);
                const batchResults = await Promise.all(
                    batch.map(item => processor(item))
                );
                results.push(...batchResults);
            }

            return results;
        }

        // é‡è¯•æœºåˆ¶
        async retry(fn, maxRetries = 3, delay = 1000) {
            let lastError;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    lastError = error;
                    console.warn(`[${this.name}] é‡è¯• ${i + 1}/${maxRetries}:`, error.message);

                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    }
                }
            }

            throw lastError;
        }

        // è·å–ç»Ÿè®¡ä¿¡æ¯
        getStats() {
            const avgTime = this.stats.executions > 0 ?
                this.stats.totalTime / this.stats.executions : 0;

            return {
                ...this.stats,
                averageTime: Math.round(avgTime),
                errorRate: this.stats.executions > 0 ?
                    (this.stats.errors / this.stats.executions * 100).toFixed(2) + '%' : '0%'
            };
        }

        // æ¸…ç†èµ„æº
        cleanup() {
            console.log(`[${this.name}] æ¸…ç†èµ„æº`);
            // å­ç±»å®ç°
        }
    }

    // URLåˆ†ææ’ä»¶
    class URLAnalyzerPlugin extends BasePlugin {
        constructor() {
            super('url_analyzer', '2.0.0');
            this.categories = new Map();
            this.cache = new Map();
            this.cacheTimeout = 5 * 60 * 1000; // 5åˆ†é’Ÿ
        }

        async initialize() {
            await super.initialize();
            await this.loadCategories();
            this.setupCacheCleanup();
        }

        async loadCategories() {
            const categoryData = app.db.query(`
                SELECT name, patterns, priority FROM url_categories
                ORDER BY priority DESC
            `);

            categoryData.forEach(row => {
                this.categories.set(row.name, {
                    patterns: JSON.parse(row.patterns),
                    priority: row.priority
                });
            });
        }

        async registerHandlers() {
            onURLAdd(
                this.withStats('analyzeURL', this.analyzeURL.bind(this))
            );

            // å®šæœŸæ¸…ç†ç¼“å­˜
            cronAdd(`${this.name}_cache_cleanup`, '*/10 * * * *', () => {
                this.cleanupCache();
            });

            // ç»Ÿè®¡æŠ¥å‘Šè·¯ç”±
            routerAdd('GET', `/api/plugins/${this.name}/stats`, (e) => {
                return e.json(200, {
                    plugin: this.name,
                    version: this.version,
                    stats: this.getStats(),
                    categories: this.categories.size,
                    cacheSize: this.cache.size
                });
            });
        }

        async analyzeURL(e) {
            if (!this.enabled) return e.next();

            const url = e.url.url;
            const cacheKey = this.generateCacheKey(url);

            // æ£€æŸ¥ç¼“å­˜
            const cached = this.getFromCache(cacheKey);
            if (cached) {
                this.applyAnalysis(e, cached);
                return e.next();
            }

            // æ‰§è¡Œåˆ†æ
            const analysis = await this.retry(async () => {
                return this.performAnalysis(url);
            });

            // ç¼“å­˜ç»“æœ
            this.setCache(cacheKey, analysis);

            // åº”ç”¨åˆ†æç»“æœ
            this.applyAnalysis(e, analysis);

            return e.next();
        }

        async performAnalysis(url) {
            const urlObj = new URL(url);
            const domain = urlObj.hostname.replace('www.', '');

            // åˆ†ç±»è¯†åˆ«
            const category = this.identifyCategory(domain, urlObj);

            // æ ‡ç­¾æå–
            const tags = await this.extractTags(urlObj, category);

            // ç½®ä¿¡åº¦è®¡ç®—
            const confidence = this.calculateConfidence(domain, category, tags);

            // å…ƒæ•°æ®æå–
            const metadata = await this.extractMetadata(urlObj);

            return {
                category,
                tags,
                confidence,
                metadata,
                analyzed_at: new Date().toISOString()
            };
        }

        identifyCategory(domain, urlObj) {
            let bestMatch = { category: 'uncategorized', score: 0 };

            for (const [category, config] of this.categories) {
                let score = 0;

                // åŸŸååŒ¹é…
                if (config.patterns.domains?.some(d => domain.includes(d))) {
                    score += 10;
                }

                // è·¯å¾„åŒ¹é…
                if (config.patterns.paths?.some(p => urlObj.pathname.includes(p))) {
                    score += 5;
                }

                // æŸ¥è¯¢å‚æ•°åŒ¹é…
                if (config.patterns.params?.some(p => urlObj.searchParams.has(p))) {
                    score += 3;
                }

                if (score > bestMatch.score) {
                    bestMatch = { category, score };
                }
            }

            return bestMatch.category;
        }

        async extractTags(urlObj, category) {
            const tags = new Set();

            // åŸºç¡€æ ‡ç­¾
            tags.add(urlObj.hostname.replace('www.', ''));

            // è·¯å¾„æ ‡ç­¾
            const pathParts = urlObj.pathname.split('/').filter(Boolean);
            pathParts.forEach(part => {
                if (part.length > 2 && part.length < 20 && !/^\d+$/.test(part)) {
                    tags.add(part);
                }
            });

            // åˆ†ç±»ç‰¹å®šæ ‡ç­¾
            const categoryConfig = this.categories.get(category);
            if (categoryConfig?.patterns?.auto_tags) {
                categoryConfig.patterns.auto_tags.forEach(tag => {
                    if (urlObj.pathname.includes(tag) || urlObj.searchParams.has(tag)) {
                        tags.add(tag);
                    }
                });
            }

            return Array.from(tags);
        }

        calculateConfidence(domain, category, tags) {
            let confidence = 0.3;

            // åŸŸååŒ¹é…
            const categoryConfig = this.categories.get(category);
            if (categoryConfig?.patterns?.domains?.includes(domain)) {
                confidence += 0.4;
            }

            // æ ‡ç­¾æ•°é‡
            confidence += Math.min(tags.length * 0.05, 0.2);

            // åˆ†ç±»ä¼˜å…ˆçº§
            if (categoryConfig?.priority) {
                confidence += Math.min(categoryConfig.priority * 0.01, 0.1);
            }

            return Math.min(confidence, 1.0);
        }

        async extractMetadata(urlObj) {
            const metadata = {
                domain: urlObj.hostname.replace('www.', ''),
                path: urlObj.pathname,
                protocol: urlObj.protocol,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                query: Object.fromEntries(urlObj.searchParams),
                hash: urlObj.hash
            };

            // URLé•¿åº¦åˆ†æ
            metadata.url_length = urlObj.href.length;
            metadata.path_depth = urlObj.pathname.split('/').length - 1;
            metadata.has_query = urlObj.searchParams.size > 0;
            metadata.has_hash = urlObj.hash.length > 0;

            return metadata;
        }

        applyAnalysis(e, analysis) {
            e.url.category = analysis.category;
            e.url.tags = analysis.tags;
            e.url.confidence = analysis.confidence;
            e.url.metadata = analysis.metadata;

            // ä¿å­˜åˆ°æ•°æ®åº“
            app.db.execute(`
                INSERT INTO url_analyses (url_id, analysis_data, created_at)
                VALUES (?, ?, datetime('now'))
                ON CONFLICT(url_id) DO UPDATE SET
                analysis_data = excluded.analysis_data,
                updated_at = datetime('now')
            `, [e.url.id, JSON.stringify(analysis)]);
        }

        // ç¼“å­˜ç®¡ç†
        generateCacheKey(url) {
            // ç®€å•çš„URLå“ˆå¸Œ
            let hash = 0;
            for (let i = 0; i < url.length; i++) {
                const char = url.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36);
        }

        getFromCache(key) {
            const cached = this.cache.get(key);
            if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.data;
            }
            this.cache.delete(key);
            return null;
        }

        setCache(key, data) {
            this.cache.set(key, {
                data,
                timestamp: Date.now()
            });

            // é™åˆ¶ç¼“å­˜å¤§å°
            if (this.cache.size > 1000) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
        }

        cleanupCache() {
            const now = Date.now();
            for (const [key, value] of this.cache) {
                if (now - value.timestamp > this.cacheTimeout) {
                    this.cache.delete(key);
                }
            }
        }

        setupCacheCleanup() {
            // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡è¿‡æœŸç¼“å­˜
            cronAdd(`${this.name}_deep_cleanup`, '0 * * * *', () => {
                this.cleanupCache();
                console.log(`[${this.name}] ç¼“å­˜æ¸…ç†å®Œæˆï¼Œå½“å‰ç¼“å­˜å¤§å°: ${this.cache.size}`);
            });
        }
    }

    return {
        BasePlugin,
        URLAnalyzerPlugin
    };
})();

// åˆå§‹åŒ–æ’ä»¶
const analyzer = new PluginSystem.URLAnalyzerPlugin();
analyzer.initialize().catch(console.error);
```

---

## ğŸ—„ï¸ æ•°æ®åº“æ“ä½œ

### æ•°æ®åº“æœ€ä½³å®è·µ

```javascript
// hooks/database-best-practices.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * æ•°æ®åº“æ“ä½œæœ€ä½³å®è·µç¤ºä¾‹
 */

class DatabaseManager {
    constructor() {
        this.queryCache = new Map();
        this.cacheTimeout = 60 * 1000; // 1åˆ†é’Ÿ
    }

    // å‚æ•°åŒ–æŸ¥è¯¢
    findUserById(userId) {
        return app.db.queryOne(`
            SELECT id, username, email, role, created_at
            FROM users
            WHERE id = ? AND deleted_at IS NULL
        `, [userId]);
    }

    // å¤æ‚æŸ¥è¯¢ä¼˜åŒ–
    getUserWithStats(userId) {
        return app.db.queryOne(`
            SELECT
                u.id,
                u.username,
                u.email,
                u.role,
                COUNT(DISTINCT up.id) as preferences_count,
                COUNT(DISTINCT us.id) as stats_count,
                COUNT(DISTINCT ur.id) as urls_count
            FROM users u
            LEFT JOIN user_preferences up ON u.id = up.user_id
            LEFT JOIN user_stats us ON u.id = us.user_id
            LEFT JOIN urls ur ON u.id = ur.user_id AND ur.deleted_at IS NULL
            WHERE u.id = ? AND u.deleted_at IS NULL
            GROUP BY u.id, u.username, u.email, u.role
        `, [userId]);
    }

    // æ‰¹é‡æ“ä½œ
    async bulkInsertURLs(urls) {
        const stmt = app.db.prepare(`
            INSERT INTO urls (id, url, title, category, user_id, created_at)
            VALUES (?, ?, ?, ?, ?, datetime('now'))
        `);

        try {
            app.db.transaction(() => {
                urls.forEach(url => {
                    stmt.run([
                        this.generateUUID(),
                        url.url,
                        url.title || '',
                        url.category || 'uncategorized',
                        url.userId
                    ]);
                });
            });
        } finally {
            stmt.finalize();
        }
    }

    // äº‹åŠ¡å¤„ç†
    async updateUserWithPreferences(userId, updates, preferences) {
        return app.db.transaction((tx) => {
            // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
            if (Object.keys(updates).length > 0) {
                const setClause = Object.keys(updates).map(key => `${key} = ?`).join(', ');
                const values = Object.values(updates);
                values.push(userId);

                tx.execute(`
                    UPDATE users
                    SET ${setClause}, updated_at = datetime('now')
                    WHERE id = ?
                `, values);
            }

            // æ›´æ–°ç”¨æˆ·åå¥½
            if (Object.keys(preferences).length > 0) {
                const setClause = Object.keys(preferences).map(key => `${key} = ?`).join(', ');
                const values = Object.values(preferences);
                values.push(userId);

                tx.execute(`
                    UPDATE user_preferences
                    SET ${setClause}, updated_at = datetime('now')
                    WHERE user_id = ?
                `, values);
            }

            return { success: true };
        });
    }

    // ç¼“å­˜æŸ¥è¯¢
    getCachedUserStats(userId) {
        const cacheKey = `user_stats_${userId}`;
        const cached = this.queryCache.get(cacheKey);

        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }

        const stats = this.calculateUserStats(userId);
        this.queryCache.set(cacheKey, {
            data: stats,
            timestamp: Date.now()
        });

        return stats;
    }

    calculateUserStats(userId) {
        return app.db.queryOne(`
            SELECT
                COUNT(CASE WHEN created_at >= datetime('now', '-7 days') THEN 1 END) as urls_this_week,
                COUNT(CASE WHEN created_at >= datetime('now', '-30 days') THEN 1 END) as urls_this_month,
                COUNT(*) as total_urls,
                COUNT(DISTINCT category) as unique_categories,
                MAX(created_at) as last_url_added
            FROM urls
            WHERE user_id = ? AND deleted_at IS NULL
        `, [userId]);
    }

    // åˆ†é¡µæŸ¥è¯¢
    getURLsByUser(userId, page = 1, limit = 20, filters = {}) {
        const offset = (page - 1) * limit;
        let whereClause = 'WHERE user_id = ? AND deleted_at IS NULL';
        const params = [userId];

        // æ·»åŠ è¿‡æ»¤æ¡ä»¶
        if (filters.category) {
            whereClause += ' AND category = ?';
            params.push(filters.category);
        }

        if (filters.search) {
            whereClause += ' AND (title LIKE ? OR url LIKE ?)';
            const searchTerm = `%${filters.search}%`;
            params.push(searchTerm, searchTerm);
        }

        // æŸ¥è¯¢æ•°æ®
        const urls = app.db.query(`
            SELECT *
            FROM urls
            ${whereClause}
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        `, [...params, limit, offset]);

        // æŸ¥è¯¢æ€»æ•°
        const totalResult = app.db.queryOne(`
            SELECT COUNT(*) as total
            FROM urls
            ${whereClause}
        `, params);

        return {
            urls,
            pagination: {
                page,
                limit,
                total: totalResult.total,
                totalPages: Math.ceil(totalResult.total / limit)
            }
        };
    }

    // å·¥å…·å‡½æ•°
    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // æ¸…ç†ç¼“å­˜
    clearCache(pattern = null) {
        if (pattern) {
            for (const key of this.queryCache.keys()) {
                if (key.includes(pattern)) {
                    this.queryCache.delete(key);
                }
            }
        } else {
            this.queryCache.clear();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const dbManager = new DatabaseManager();

onURLAdd((e) => {
    // ä½¿ç”¨æ•°æ®åº“ç®¡ç†å™¨
    const userStats = dbManager.getCachedUserStats(e.user.id);
    console.log('ç”¨æˆ·ç»Ÿè®¡:', userStats);

    // æ‰¹é‡æ’å…¥ç›¸å…³URL
    if (e.url.related_urls) {
        dbManager.bulkInsertURLs(e.url.related_urls.map(url => ({
            url: url,
            userId: e.user.id,
            category: e.url.category
        })));
    }

    return e.next();
});
```

---

## ğŸŒ APIå¼€å‘

### RESTful APIè®¾è®¡

```javascript
// hooks/api-development.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * APIå¼€å‘ç¤ºä¾‹
 */

// APIå“åº”æ ¼å¼æ ‡å‡†åŒ–
function createResponse(success, data = null, error = null, meta = null) {
    const response = {
        success,
        timestamp: new Date().toISOString()
    };

    if (success) {
        response.data = data;
        if (meta) response.meta = meta;
    } else {
        response.error = error;
    }

    return response;
}

// åˆ†é¡µå“åº”æ ¼å¼
function createPaginatedResponse(items, pagination) {
    return createResponse(true, items, null, pagination);
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
function errorHandler(handler) {
    return async (e) => {
        try {
            return await handler(e);
        } catch (error) {
            console.error('APIé”™è¯¯:', error);

            // è®°å½•é”™è¯¯æ—¥å¿—
            app.db.execute(`
                INSERT INTO api_errors (
                    endpoint, method, error_message, stack_trace, created_at
                ) VALUES (?, ?, ?, ?, datetime('now'))
            `, [
                e.path,
                e.method,
                error.message,
                error.stack || ''
            ]);

            return e.json(500, createResponse(false, null, {
                code: 'INTERNAL_ERROR',
                message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
            }));
        }
    };
}

// URLç®¡ç†API
routerAdd('GET', '/api/plugins/urls', errorHandler(async (e) => {
    const { page = 1, limit = 20, category, search, sort = 'created_at', order = 'desc' } = e.query;
    const userId = e.user?.id;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    // å‚æ•°éªŒè¯
    const pageNum = parseInt(page);
    const limitNum = Math.min(parseInt(limit), 100); // æœ€å¤§100æ¡

    if (pageNum < 1 || limitNum < 1) {
        return e.json(400, createResponse(false, null, {
            code: 'INVALID_PARAMETERS',
            message: 'åˆ†é¡µå‚æ•°æ— æ•ˆ'
        }));
    }

    // æ„å»ºè¿‡æ»¤å™¨
    const filters = {};
    if (category) filters.category = category;
    if (search) filters.search = search;

    // æŸ¥è¯¢æ•°æ®
    const result = dbManager.getURLsByUser(userId, pageNum, limitNum, filters);

    // æ·»åŠ æ’åº
    if (sort && order) {
        result.urls = sortURLs(result.urls, sort, order);
    }

    return e.json(200, createPaginatedResponse(result.urls, result.pagination));
}));

// URLè¯¦æƒ…API
routerAdd('GET', '/api/plugins/urls/:id', errorHandler(async (e) => {
    const { id } = e.pathParams;
    const userId = e.user?.id;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    // æŸ¥è¯¢URLè¯¦æƒ…
    const url = app.db.queryOne(`
        SELECT
            u.*,
            up.category as suggested_category,
            ua.tags as auto_tags,
            ua.confidence as analysis_confidence
        FROM urls u
        LEFT JOIN url_predictions up ON u.id = up.url_id
        LEFT JOIN url_analyses ua ON u.id = ua.url_id
        WHERE u.id = ? AND u.user_id = ? AND u.deleted_at IS NULL
    `, [id, userId]);

    if (!url) {
        return e.json(404, createResponse(false, null, {
            code: 'NOT_FOUND',
            message: 'URLä¸å­˜åœ¨'
        }));
    }

    // è§£æJSONå­—æ®µ
    url.tags = url.tags ? JSON.parse(url.tags) : [];
    url.auto_tags = url.auto_tags ? JSON.parse(url.auto_tags) : [];

    // è·å–è®¿é—®ç»Ÿè®¡
    const accessStats = app.db.queryOne(`
        SELECT
            COUNT(*) as total_access,
            COUNT(DISTINCT DATE(access_time)) as unique_days,
            MAX(access_time) as last_access
        FROM access_stats
        WHERE url_id = ?
    `, [id]);

    url.access_stats = accessStats;

    return e.json(200, createResponse(true, url));
}));

// åˆ›å»ºURL API
routerAdd('POST', '/api/plugins/urls', errorHandler(async (e) => {
    const userId = e.user?.id;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    const { url, title, category, tags = [] } = e.body;

    // å‚æ•°éªŒè¯
    if (!url || typeof url !== 'string') {
        return e.json(400, createResponse(false, null, {
            code: 'INVALID_URL',
            message: 'URLä¸èƒ½ä¸ºç©º'
        }));
    }

    try {
        new URL(url); // éªŒè¯URLæ ¼å¼
    } catch {
        return e.json(400, createResponse(false, null, {
            code: 'INVALID_URL_FORMAT',
            message: 'URLæ ¼å¼æ— æ•ˆ'
        }));
    }

    // æ£€æŸ¥é‡å¤
    const existing = app.db.queryOne(`
        SELECT id FROM urls WHERE url = ? AND user_id = ? AND deleted_at IS NULL
    `, [url, userId]);

    if (existing) {
        return e.json(409, createResponse(false, null, {
            code: 'DUPLICATE_URL',
            message: 'URLå·²å­˜åœ¨'
        }));
    }

    // åˆ›å»ºURLè®°å½•
    const urlId = dbManager.generateUUID();
    const result = app.db.execute(`
        INSERT INTO urls (id, url, title, category, tags, user_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
    `, [urlId, url, title || '', category || 'uncategorized', JSON.stringify(tags), userId]);

    // è·å–åˆ›å»ºçš„URL
    const createdUrl = app.db.queryOne(`
        SELECT * FROM urls WHERE id = ?
    `, [urlId]);

    createdUrl.tags = JSON.parse(createdUrl.tags);

    return e.json(201, createResponse(true, createdUrl, null, {
        location: `/api/plugins/urls/${urlId}`
    }));
}));

// æ›´æ–°URL API
routerAdd('PUT', '/api/plugins/urls/:id', errorHandler(async (e) => {
    const { id } = e.pathParams;
    const userId = e.user?.id;
    const { title, category, tags } = e.body;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    // æ£€æŸ¥URLæ˜¯å¦å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
    const existingUrl = app.db.queryOne(`
        SELECT id FROM urls WHERE id = ? AND user_id = ? AND deleted_at IS NULL
    `, [id, userId]);

    if (!existingUrl) {
        return e.json(404, createResponse(false, null, {
            code: 'NOT_FOUND',
            message: 'URLä¸å­˜åœ¨'
        }));
    }

    // æ„å»ºæ›´æ–°è¯­å¥
    const updates = [];
    const params = [];

    if (title !== undefined) {
        updates.push('title = ?');
        params.push(title);
    }

    if (category !== undefined) {
        updates.push('category = ?');
        params.push(category);
    }

    if (tags !== undefined) {
        updates.push('tags = ?');
        params.push(JSON.stringify(tags));
    }

    if (updates.length === 0) {
        return e.json(400, createResponse(false, null, {
            code: 'NO_UPDATES',
            message: 'æ²¡æœ‰è¦æ›´æ–°çš„å­—æ®µ'
        }));
    }

    updates.push('updated_at = datetime(\'now\')');
    params.push(id);

    // æ‰§è¡Œæ›´æ–°
    app.db.execute(`
        UPDATE urls SET ${updates.join(', ')} WHERE id = ?
    `, params);

    // è·å–æ›´æ–°åçš„URL
    const updatedUrl = app.db.queryOne(`
        SELECT * FROM urls WHERE id = ?
    `, [id]);

    updatedUrl.tags = JSON.parse(updatedUrl.tags);

    return e.json(200, createResponse(true, updatedUrl));
}));

// åˆ é™¤URL API
routerAdd('DELETE', '/api/plugins/urls/:id', errorHandler(async (e) => {
    const { id } = e.pathParams;
    const userId = e.user?.id;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    // è½¯åˆ é™¤URL
    const result = app.db.execute(`
        UPDATE urls
        SET deleted_at = datetime('now'), updated_at = datetime('now')
        WHERE id = ? AND user_id = ? AND deleted_at IS NULL
    `, [id, userId]);

    if (result.changes === 0) {
        return e.json(404, createResponse(false, null, {
            code: 'NOT_FOUND',
            message: 'URLä¸å­˜åœ¨'
        }));
    }

    return e.json(200, createResponse(true, { deleted: true }));
}));

// æ‰¹é‡æ“ä½œAPI
routerAdd('POST', '/api/plugins/urls/batch', errorHandler(async (e) => {
    const userId = e.user?.id;
    const { action, ids, data } = e.body;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    if (!action || !Array.isArray(ids) || ids.length === 0) {
        return e.json(400, createResponse(false, null, {
            code: 'INVALID_PARAMETERS',
            message: 'å‚æ•°æ— æ•ˆ'
        }));
    }

    // é™åˆ¶æ‰¹é‡æ“ä½œæ•°é‡
    if (ids.length > 100) {
        return e.json(400, createResponse(false, null, {
            code: 'TOO_MANY_ITEMS',
            message: 'æ‰¹é‡æ“ä½œæ•°é‡ä¸èƒ½è¶…è¿‡100ä¸ª'
        }));
    }

    let result;

    switch (action) {
        case 'delete':
            result = batchDeleteURLs(userId, ids);
            break;
        case 'update':
            result = batchUpdateURLs(userId, ids, data);
            break;
        case 'category':
            result = batchUpdateCategory(userId, ids, data.category);
            break;
        default:
            return e.json(400, createResponse(false, null, {
                code: 'INVALID_ACTION',
                message: 'ä¸æ”¯æŒçš„æ“ä½œ'
            }));
    }

    return e.json(200, createResponse(true, result));
}));

// æ‰¹é‡åˆ é™¤å‡½æ•°
function batchDeleteURLs(userId, ids) {
    const placeholders = ids.map(() => '?').join(',');

    const result = app.db.execute(`
        UPDATE urls
        SET deleted_at = datetime('now'), updated_at = datetime('now')
        WHERE id IN (${placeholders}) AND user_id = ? AND deleted_at IS NULL
    `, [...ids, userId]);

    return {
        action: 'delete',
        requested: ids.length,
        processed: result.changes
    };
}

// æ‰¹é‡æ›´æ–°å‡½æ•°
function batchUpdateURLs(userId, ids, data) {
    const allowedFields = ['title', 'category'];
    const updates = [];
    const params = [];

    for (const [key, value] of Object.entries(data)) {
        if (allowedFields.includes(key)) {
            updates.push(`${key} = ?`);
            params.push(value);
        }
    }

    if (updates.length === 0) {
        throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„æ›´æ–°å­—æ®µ');
    }

    updates.push('updated_at = datetime(\'now\')');
    const placeholders = ids.map(() => '?').join(',');

    const result = app.db.execute(`
        UPDATE urls
        SET ${updates.join(', ')}
        WHERE id IN (${placeholders}) AND user_id = ? AND deleted_at IS NULL
    `, [...params, ...ids, userId]);

    return {
        action: 'update',
        updates: updates.length - 1, // å‡å» updated_at å­—æ®µ
        requested: ids.length,
        processed: result.changes
    };
}

// å·¥å…·å‡½æ•°ï¼šæ’åºURLs
function sortURLs(urls, field, order) {
    const multiplier = order === 'desc' ? -1 : 1;

    return urls.sort((a, b) => {
        let aVal = a[field];
        let bVal = b[field];

        // ç‰¹æ®Šå­—æ®µå¤„ç†
        if (field === 'tags') {
            aVal = Array.isArray(aVal) ? aVal.length : 0;
            bVal = Array.isArray(bVal) ? bVal.length : 0;
        }

        if (aVal < bVal) return -1 * multiplier;
        if (aVal > bVal) return 1 * multiplier;
        return 0;
    });
}

// ç»Ÿè®¡API
routerAdd('GET', '/api/plugins/stats', errorHandler(async (e) => {
    const userId = e.user?.id;

    if (!userId) {
        return e.json(401, createResponse(false, null, {
            code: 'UNAUTHORIZED',
            message: 'éœ€è¦ç™»å½•'
        }));
    }

    // è·å–ç”¨æˆ·ç»Ÿè®¡
    const stats = app.db.queryOne(`
        SELECT
            COUNT(*) as total_urls,
            COUNT(DISTINCT category) as unique_categories,
            COUNT(CASE WHEN created_at >= datetime('now', '-7 days') THEN 1 END) as urls_this_week,
            COUNT(CASE WHEN created_at >= datetime('now', '-30 days') THEN 1 END) as urls_this_month,
            MAX(created_at) as last_url_added
        FROM urls
        WHERE user_id = ? AND deleted_at IS NULL
    `, [userId]);

    // åˆ†ç±»ç»Ÿè®¡
    const categoryStats = app.db.query(`
        SELECT category, COUNT(*) as count
        FROM urls
        WHERE user_id = ? AND deleted_at IS NULL
        GROUP BY category
        ORDER BY count DESC
    `, [userId]);

    // æ—¶é—´è¶‹åŠ¿ï¼ˆæœ€è¿‘30å¤©ï¼‰
    const trendStats = app.db.query(`
        SELECT
            DATE(created_at) as date,
            COUNT(*) as count
        FROM urls
        WHERE user_id = ?
            AND created_at >= datetime('now', '-30 days')
            AND deleted_at IS NULL
        GROUP BY DATE(created_at)
        ORDER BY date ASC
    `, [userId]);

    return e.json(200, createResponse(true, {
        overview: stats,
        categories: categoryStats,
        trends: trendStats
    });
}));
```

---

## ğŸ§ª æµ‹è¯•å’Œè°ƒè¯•

### å•å…ƒæµ‹è¯•æ¡†æ¶

```javascript
// scripts/test-runner.js
/**
 * æ’ä»¶æµ‹è¯•æ¡†æ¶
 */

class PluginTester {
    constructor() {
        this.tests = [];
        this.passed = 0;
        this.failed = 0;
    }

    // æµ‹è¯•ç”¨ä¾‹
    test(name, fn) {
        this.tests.push({ name, fn });
    }

    // æ–­è¨€å‡½æ•°
    assert(condition, message = 'æ–­è¨€å¤±è´¥') {
        if (!condition) {
            throw new Error(message);
        }
    }

    assertEqual(actual, expected, message = 'å€¼ä¸ç›¸ç­‰') {
        this.assert(actual === expected, `${message}: æœŸæœ› ${expected}, å®é™… ${actual}`);
    }

    assertDeepEqual(actual, expected, message = 'å¯¹è±¡ä¸ç›¸ç­‰') {
        this.assert(JSON.stringify(actual) === JSON.stringify(expected), message);
    }

    assertThrows(fn, message = 'åº”è¯¥æŠ›å‡ºå¼‚å¸¸') {
        let threw = false;
        try {
            fn();
        } catch {
            threw = true;
        }
        this.assert(threw, message);
    }

    // è¿è¡Œæ‰€æœ‰æµ‹è¯•
    async run() {
        console.log('å¼€å§‹è¿è¡Œæ’ä»¶æµ‹è¯•...\n');

        for (const test of this.tests) {
            try {
                await test.fn();
                console.log(`âœ… ${test.name}`);
                this.passed++;
            } catch (error) {
                console.log(`âŒ ${test.name}`);
                console.log(`   é”™è¯¯: ${error.message}\n`);
                this.failed++;
            }
        }

        console.log(`\næµ‹è¯•å®Œæˆ: ${this.passed} é€šè¿‡, ${this.failed} å¤±è´¥`);
        return this.failed === 0;
    }
}

// æ¨¡æ‹Ÿåº”ç”¨ç¯å¢ƒ
const mockApp = {
    db: {
        query: (sql, params = []) => {
            // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
            console.log(`[MOCK DB Query] ${sql}`, params);
            return [];
        },
        queryOne: (sql, params = []) => {
            console.log(`[MOCK DB QueryOne] ${sql}`, params);
            return null;
        },
        execute: (sql, params = []) => {
            console.log(`[MOCK DB Execute] ${sql}`, params);
            return { changes: 1, lastInsertRowid: 'mock-id' };
        }
    },
    config: {
        get: (key, defaultValue = null) => defaultValue,
        getString: (key, defaultValue = '') => defaultValue,
        getBool: (key, defaultValue = false) => defaultValue,
        getInt: (key, defaultValue = 0) => defaultValue
    },
    mail: {
        send: (options) => {
            console.log(`[MOCK Mail] å‘é€é‚®ä»¶:`, options);
        }
    },
    triggerCustom: (event, data) => {
        console.log(`[MOCK Event] è§¦å‘äº‹ä»¶: ${event}`, data);
    }
};

// å…¨å±€æ¨¡æ‹Ÿå¯¹è±¡
global.app = mockApp;
global.console = console;

// æµ‹è¯•ç¤ºä¾‹
async function runPluginTests() {
    const tester = new PluginTester();

    // æµ‹è¯•URLåˆ†ç±»åŠŸèƒ½
    tester.test('URLåˆ†ç±» - GitHubé“¾æ¥', () => {
        const analyzer = new URLAnalyzer();
        const result = analyzer.identifyCategory('github.com/user/repo');
        tester.assertEqual(result, 'development');
    });

    tester.test('URLåˆ†ç±» - YouTubeé“¾æ¥', () => {
        const analyzer = new URLAnalyzer();
        const result = analyzer.identifyCategory('youtube.com/watch?v=123');
        tester.assertEqual(result, 'video');
    });

    tester.test('æ ‡ç­¾æå– - åŒ…å«è·¯å¾„çš„URL', () => {
        const urlObj = new URL('https://github.com/user/repo/docs');
        const analyzer = new URLAnalyzer();
        const tags = analyzer.extractTags(urlObj, 'development');
        tester.assert(tags.includes('github.com'));
        tester.assert(tags.includes('user'));
        tester.assert(tags.includes('repo'));
        tester.assert(tags.includes('docs'));
    });

    tester.test('ç½®ä¿¡åº¦è®¡ç®— - é«˜ç½®ä¿¡åº¦åŒ¹é…', () => {
        const analyzer = new URLAnalyzer();
        const confidence = analyzer.calculateConfidence('github.com', 'development', ['github.com', 'docs']);
        tester.assert(confidence > 0.8);
    });

    tester.test('ç¼“å­˜åŠŸèƒ½ - ç¼“å­˜å‘½ä¸­', async () => {
        const analyzer = new URLAnalyzer();
        const url = 'https://example.com';

        // ç¬¬ä¸€æ¬¡è°ƒç”¨
        const result1 = await analyzer.analyzeURL(url);

        // ç¬¬äºŒæ¬¡è°ƒç”¨åº”è¯¥ä½¿ç”¨ç¼“å­˜
        const result2 = await analyzer.analyzeURL(url);

        tester.assertEqual(result1.category, result2.category);
        tester.assertEqual(result1.tags.length, result2.tags.length);
    });

    // æ•°æ®åº“æ“ä½œæµ‹è¯•
    tester.test('æ•°æ®åº“æŸ¥è¯¢ - å‚æ•°åŒ–æŸ¥è¯¢', () => {
        const dbManager = new DatabaseManager();
        const user = dbManager.findUserById('user-123');
        tester.assert(user !== null); // æ¨¡æ‹Ÿè¿”å›éç©ºå€¼
    });

    tester.test('æ‰¹é‡æ“ä½œ - æ‰¹é‡æ’å…¥URLs', async () => {
        const dbManager = new DatabaseManager();
        const urls = [
            { url: 'https://example1.com', userId: 'user-1' },
            { url: 'https://example2.com', userId: 'user-1' }
        ];

        // åº”è¯¥ä¸æŠ›å‡ºå¼‚å¸¸
        await dbManager.bulkInsertURLs(urls);
        tester.assert(true);
    });

    // APIå“åº”æµ‹è¯•
    tester.test('APIå“åº”æ ¼å¼ - æˆåŠŸå“åº”', () => {
        const response = createResponse(true, { id: 123 });
        tester.assert(response.success);
        tester.assertEqual(response.data.id, 123);
        tester.assert(response.timestamp);
    });

    tester.test('APIå“åº”æ ¼å¼ - é”™è¯¯å“åº”', () => {
        const response = createResponse(false, null, {
            code: 'ERROR_CODE',
            message: 'é”™è¯¯ä¿¡æ¯'
        });
        tester.assert(!response.success);
        tester.assertEqual(response.error.code, 'ERROR_CODE');
    });

    // é”™è¯¯å¤„ç†æµ‹è¯•
    tester.test('é”™è¯¯å¤„ç† - URLæ ¼å¼éªŒè¯', () => {
        tester.assertThrows(() => {
            new URL('invalid-url');
        });
    });

    tester.test('é”™è¯¯å¤„ç† - é‡è¯•æœºåˆ¶', async () => {
        let attempts = 0;
        const result = await retry(() => {
            attempts++;
            if (attempts < 3) {
                throw new Error('æ¨¡æ‹Ÿå¤±è´¥');
            }
            return 'success';
        }, 3);

        tester.assertEqual(result, 'success');
        tester.assertEqual(attempts, 3);
    });

    return await tester.run();
}

// å·¥å…·å‡½æ•°
function createResponse(success, data = null, error = null, meta = null) {
    const response = {
        success,
        timestamp: new Date().toISOString()
    };

    if (success) {
        response.data = data;
        if (meta) response.meta = meta;
    } else {
        response.error = error;
    }

    return response;
}

async function retry(fn, maxRetries = 3, delay = 100) {
    let lastError;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            if (i < maxRetries - 1) {
                await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
            }
        }
    }

    throw lastError;
}

// è¿è¡Œæµ‹è¯•
if (require.main === module) {
    runPluginTests().then(success => {
        process.exit(success ? 0 : 1);
    }).catch(error => {
        console.error('æµ‹è¯•è¿è¡Œå¤±è´¥:', error);
        process.exit(1);
    });
}

module.exports = { PluginTester, runPluginTests };
```

### è°ƒè¯•å·¥å…·

```javascript
// hooks/debug-tools.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * æ’ä»¶è°ƒè¯•å·¥å…·
 */

class DebugTools {
    constructor() {
        this.enabled = app.config.getBool('debug.enabled', false);
        this.logLevel = app.config.getString('debug.log_level', 'info');
        this.logFile = app.config.getString('debug.log_file', '');
    }

    // æ—¥å¿—è®°å½•
    log(level, message, data = null) {
        if (!this.enabled) return;

        const levels = ['debug', 'info', 'warn', 'error'];
        const currentLevelIndex = levels.indexOf(this.logLevel);
        const messageLevelIndex = levels.indexOf(level);

        if (messageLevelIndex < currentLevelIndex) return;

        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level: level.toUpperCase(),
            message,
            data
        };

        // æ§åˆ¶å°è¾“å‡º
        const colorMap = {
            debug: '\x1b[36m', // é’è‰²
            info: '\x1b[32m',  // ç»¿è‰²
            warn: '\x1b[33m',  // é»„è‰²
            error: '\x1b[31m'  // çº¢è‰²
        };

        console.log(`${colorMap[level]}[${logEntry.timestamp}] ${logEntry.level}: ${message}\x1b[0m`);
        if (data) {
            console.log(JSON.stringify(data, null, 2));
        }

        // æ–‡ä»¶è¾“å‡º
        if (this.logFile) {
            this.writeToFile(logEntry);
        }
    }

    // å†™å…¥æ–‡ä»¶
    writeToFile(logEntry) {
        try {
            const fs = require('fs');
            const logLine = JSON.stringify(logEntry) + '\n';
            fs.appendFileSync(this.logFile, logLine);
        } catch (error) {
            console.error('å†™å…¥æ—¥å¿—æ–‡ä»¶å¤±è´¥:', error);
        }
    }

    // æ€§èƒ½ç›‘æ§
    time(label) {
        if (!this.enabled) return;
        console.time(label);
    }

    timeEnd(label) {
        if (!this.enabled) return;
        console.timeEnd(label);
    }

    // å†…å­˜ä½¿ç”¨ç›‘æ§
    memoryUsage(label = '') {
        if (!this.enabled) return;

        const usage = process.memoryUsage();
        this.log('debug', `å†…å­˜ä½¿ç”¨ ${label}`, {
            rss: Math.round(usage.rss / 1024 / 1024) + 'MB',
            heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + 'MB',
            heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + 'MB',
            external: Math.round(usage.external / 1024 / 1024) + 'MB'
        });
    }

    // æ•°æ®åº“æŸ¥è¯¢ç›‘æ§
    monitorQuery(sql, params = [], startTime = null) {
        if (!this.enabled) return;

        const duration = startTime ? Date.now() - startTime : 0;
        this.log('debug', 'æ•°æ®åº“æŸ¥è¯¢', {
            sql: sql.replace(/\s+/g, ' ').trim(),
            params,
            duration: duration + 'ms'
        });

        if (duration > 1000) {
            this.log('warn', 'æ…¢æŸ¥è¯¢æ£€æµ‹', {
                sql: sql.replace(/\s+/g, ' ').trim(),
                duration: duration + 'ms'
            });
        }
    }

    // äº‹ä»¶è¿½è¸ª
    traceEvent(event, data = {}) {
        if (!this.enabled) return;

        this.log('info', `äº‹ä»¶è§¦å‘: ${event}`, {
            event,
            data,
            timestamp: new Date().toISOString()
        });
    }

    // é”™è¯¯è¿½è¸ª
    traceError(error, context = {}) {
        this.log('error', 'é”™è¯¯è¿½è¸ª', {
            message: error.message,
            stack: error.stack,
            context,
            timestamp: new Date().toISOString()
        });
    }
}

// å…¨å±€è°ƒè¯•å®ä¾‹
const debug = new DebugTools();

// æ•°æ®åº“æŸ¥è¯¢åŒ…è£…
const originalQuery = app.db.query;
const originalQueryOne = app.db.queryOne;
const originalExecute = app.db.execute;

app.db.query = function(sql, ...params) {
    const startTime = Date.now();
    const result = originalQuery.apply(this, [sql, ...params]);
    debug.monitorQuery(sql, params, startTime);
    return result;
};

app.db.queryOne = function(sql, ...params) {
    const startTime = Date.now();
    const result = originalQueryOne.apply(this, [sql, ...params]);
    debug.monitorQuery(sql, params, startTime);
    return result;
};

app.db.execute = function(sql, ...params) {
    const startTime = Date.now();
    const result = originalExecute.apply(this, [sql, ...params]);
    debug.monitorQuery(sql, params, startTime);
    return result;
};

// äº‹ä»¶è¿½è¸ªåŒ…è£…
const originalOnURLAdd = onURLAdd;
onURLAdd = function(handler) {
    return originalOnURLAdd(function(e) {
        debug.traceEvent('URL_ADD', {
            url: e.url.url,
            user: e.user?.username
        });

        const startTime = Date.now();
        try {
            const result = handler.call(this, e);
            debug.timeEnd('URL_ADDå¤„ç†');
            return result;
        } catch (error) {
            debug.traceError(error, {
                event: 'URL_ADD',
                url: e.url.url
            });
            throw error;
        }
    });
};

// è°ƒè¯•è·¯ç”±
routerAdd('GET', '/api/plugins/debug/status', (e) => {
    const status = {
        enabled: debug.enabled,
        logLevel: debug.logLevel,
        logFile: debug.logFile,
        memory: process.memoryUsage(),
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    };

    return e.json(200, status);
});

routerAdd('GET', '/api/plugins/debug/logs', (e) => {
    const { level = 'info', limit = 100 } = e.query;

    if (!debug.enabled || !debug.logFile) {
        return e.json(400, { error: 'è°ƒè¯•åŠŸèƒ½æœªå¯ç”¨' });
    }

    try {
        const fs = require('fs');
        const content = fs.readFileSync(debug.logFile, 'utf8');
        const lines = content.split('\n').filter(Boolean).slice(-limit);
        const logs = lines.map(line => {
            try {
                return JSON.parse(line);
            } catch {
                return { message: line };
            }
        }).filter(log => log.level === level.toUpperCase());

        return e.json(200, logs);
    } catch (error) {
        return e.json(500, { error: 'è¯»å–æ—¥å¿—å¤±è´¥' });
    }
});

// å¯¼å‡ºè°ƒè¯•å·¥å…·
global.debug = debug;
```

---

## ğŸ“¦ éƒ¨ç½²å’Œå‘å¸ƒ

### æ’ä»¶æ‰“åŒ…

```bash
#!/bin/bash
# scripts/build-plugin.sh

# æ’ä»¶æ‰“åŒ…è„šæœ¬

PLUGIN_NAME="$1"
PLUGIN_VERSION="$2"
OUTPUT_DIR="./dist"

if [ -z "$PLUGIN_NAME" ]; then
    echo "ç”¨æ³•: $0 <plugin_name> [version]"
    exit 1
fi

if [ -z "$PLUGIN_VERSION" ]; then
    PLUGIN_VERSION="1.0.0"
fi

echo "å¼€å§‹æ‰“åŒ…æ’ä»¶: $PLUGIN_NAME v$PLUGIN_VERSION"

# åˆ›å»ºè¾“å‡ºç›®å½•
mkdir -p "$OUTPUT_DIR"

# éªŒè¯æ’ä»¶æ–‡ä»¶
echo "éªŒè¯æ’ä»¶..."
./urldb plugin validate "hooks/${PLUGIN_NAME}.pb.js"

if [ $? -ne 0 ]; then
    echo "æ’ä»¶éªŒè¯å¤±è´¥ï¼Œåœæ­¢æ‰“åŒ…"
    exit 1
fi

# åˆ›å»ºæ’ä»¶æ¸…å•
cat > "$OUTPUT_DIR/${PLUGIN_NAME}.json" << EOF
{
    "name": "$PLUGIN_NAME",
    "version": "$PLUGIN_VERSION",
    "description": "URLDBæ’ä»¶ - $PLUGIN_NAME",
    "author": "URLDB Team",
    "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "files": [
        "hooks/${PLUGIN_NAME}.pb.js"
    ],
    "dependencies": {},
    "permissions": [
        "database.read",
        "database.write",
        "api.read",
        "config.read"
    ]
}
EOF

# å¤åˆ¶æ’ä»¶æ–‡ä»¶
cp "hooks/${PLUGIN_NAME}.pb.js" "$OUTPUT_DIR/"

# åˆ›å»ºå®‰è£…è„šæœ¬
cat > "$OUTPUT_DIR/install.sh" << EOF
#!/bin/bash
# æ’ä»¶å®‰è£…è„šæœ¬

echo "å®‰è£…æ’ä»¶: $PLUGIN_NAME"

# å¤åˆ¶æ–‡ä»¶
cp "${PLUGIN_NAME}.pb.js" "./hooks/"
cp "${PLUGIN_NAME}.json" "./plugins/"

# éªŒè¯å®‰è£…
./urldb plugin validate "hooks/${PLUGIN_NAME}.pb.js"

echo "æ’ä»¶å®‰è£…å®Œæˆ"
EOF

chmod +x "$OUTPUT_DIR/install.sh"

# åˆ›å»ºå‹ç¼©åŒ…
cd "$OUTPUT_DIR"
tar -czf "${PLUGIN_NAME}-v${PLUGIN_VERSION}.tar.gz" \
    "${PLUGIN_NAME}.pb.js" \
    "${PLUGIN_NAME}.json" \
    "install.sh"

echo "æ‰“åŒ…å®Œæˆ: ${OUTPUT_DIR}/${PLUGIN_NAME}-v${PLUGIN_VERSION}.tar.gz"
```

### ç‰ˆæœ¬ç®¡ç†

```javascript
// scripts/version-manager.js
/**
 * æ’ä»¶ç‰ˆæœ¬ç®¡ç†å™¨
 */

const fs = require('fs');
const path = require('path');

class VersionManager {
    constructor(pluginDir = './hooks') {
        this.pluginDir = pluginDir;
        this.manifestPath = path.join(pluginDir, 'manifest.json');
    }

    // è¯»å–æ’ä»¶æ¸…å•
    readManifest() {
        if (!fs.existsSync(this.manifestPath)) {
            return { plugins: {} };
        }

        return JSON.parse(fs.readFileSync(this.manifestPath, 'utf8'));
    }

    // å†™å…¥æ’ä»¶æ¸…å•
    writeManifest(manifest) {
        fs.writeFileSync(this.manifestPath, JSON.stringify(manifest, null, 2));
    }

    // æ³¨å†Œæ’ä»¶
    registerPlugin(name, version, metadata = {}) {
        const manifest = this.readManifest();

        manifest.plugins[name] = {
            version,
            registered_at: new Date().toISOString(),
            ...metadata
        };

        this.writeManifest(manifest);
        console.log(`æ’ä»¶ ${name} v${version} æ³¨å†ŒæˆåŠŸ`);
    }

    // è·å–æ’ä»¶ç‰ˆæœ¬
    getPluginVersion(name) {
        const manifest = this.readManifest();
        return manifest.plugins[name]?.version;
    }

    // æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
    checkCompatibility(requiredVersion, currentVersion) {
        const required = this.parseVersion(requiredVersion);
        const current = this.parseVersion(currentVersion);

        // ä¸»ç‰ˆæœ¬å¿…é¡»åŒ¹é…
        if (required.major !== current.major) {
            return false;
        }

        // æ¬¡ç‰ˆæœ¬å‘åå…¼å®¹
        if (current.minor < required.minor) {
            return false;
        }

        return true;
    }

    // è§£æç‰ˆæœ¬å·
    parseVersion(version) {
        const parts = version.split('.').map(Number);
        return {
            major: parts[0] || 0,
            minor: parts[1] || 0,
            patch: parts[2] || 0
        };
    }

    // å‡çº§æ’ä»¶ç‰ˆæœ¬
    upgradePlugin(name, newVersion) {
        const manifest = this.readManifest();
        const plugin = manifest.plugins[name];

        if (!plugin) {
            throw new Error(`æ’ä»¶ ${name} ä¸å­˜åœ¨`);
        }

        const oldVersion = plugin.version;

        if (!this.checkCompatibility(newVersion, oldVersion)) {
            throw new Error(`ç‰ˆæœ¬ ${newVersion} ä¸å½“å‰ç‰ˆæœ¬ ${oldVersion} ä¸å…¼å®¹`);
        }

        plugin.version = newVersion;
        plugin.upgraded_at = new Date().toISOString();
        plugin.previous_version = oldVersion;

        this.writeManifest(manifest);
        console.log(`æ’ä»¶ ${name} ä» ${oldVersion} å‡çº§åˆ° ${newVersion}`);
    }

    // åˆ—å‡ºæ‰€æœ‰æ’ä»¶
    listPlugins() {
        const manifest = this.readManifest();
        return Object.entries(manifest.plugins).map(([name, info]) => ({
            name,
            ...info
        }));
    }
}

// ä½¿ç”¨ç¤ºä¾‹
if (require.main === module) {
    const vm = new VersionManager();
    const command = process.argv[2];
    const name = process.argv[3];
    const version = process.argv[4];

    switch (command) {
        case 'register':
            vm.registerPlugin(name, version);
            break;
        case 'upgrade':
            vm.upgradePlugin(name, version);
            break;
        case 'list':
            console.log(JSON.stringify(vm.listPlugins(), null, 2));
            break;
        case 'version':
            console.log(vm.getPluginVersion(name));
            break;
        default:
            console.log('ç”¨æ³•: node version-manager.js <command> <name> [version]');
            console.log('å‘½ä»¤: register, upgrade, list, version');
    }
}

module.exports = VersionManager;
```

---

## ğŸ“‹ æœ€ä½³å®è·µ

### 1. ä»£ç è§„èŒƒ

```javascript
// hooks/coding-standards.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * ä»£ç è§„èŒƒç¤ºä¾‹
 */

// âœ… å¥½çš„å®è·µ
const URLAnalyzer = {
    // å¸¸é‡å®šä¹‰
    CATEGORIES: {
        DEVELOPMENT: ['github.com', 'stackoverflow.com'],
        VIDEO: ['youtube.com', 'bilibili.com'],
        SOCIAL: ['twitter.com', 'facebook.com']
    },

    // é…ç½®
    config: {
        cacheTimeout: 5 * 60 * 1000,
        maxRetries: 3,
        batchSize: 100
    },

    // åˆå§‹åŒ–
    initialize() {
        this.loadConfig();
        this.setupEventHandlers();
    },

    // å•ä¸€èŒè´£å‡½æ•°
    categorizeURL(url) {
        const domain = this.extractDomain(url);
        return this.findCategory(domain);
    },

    // é”™è¯¯å¤„ç†
    async processURL(url) {
        try {
            const result = await this.analyzeURL(url);
            return result;
        } catch (error) {
            console.error('URLå¤„ç†å¤±è´¥:', error);
            return this.getDefaultResult(url);
        }
    },

    // æ–‡æ¡£æ³¨é‡Š
    /**
     * ä»URLæå–åŸŸå
     * @param {string} url - å®Œæ•´URL
     * @returns {string} åŸŸåï¼ˆä¸å«wwwï¼‰
     */
    extractDomain(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname.replace(/^www\./, '');
        } catch {
            return '';
        }
    }
};

// âŒ é¿å…çš„å®è·µ
const badExample = {
    // é¿å…å…¨å±€å˜é‡
    globalData: {},

    // é¿å…è¿‡é•¿çš„å‡½æ•°
    processEverything(data) {
        // 100å¤šè¡Œçš„å¤„ç†é€»è¾‘
        // åº”è¯¥æ‹†åˆ†ä¸ºå¤šä¸ªå°å‡½æ•°
    },

    // é¿å…ç¡¬ç¼–ç 
    categorize(url) {
        if (url.includes('github.com')) return 'dev';
        if (url.includes('youtube.com')) return 'video';
        // åº”è¯¥ä½¿ç”¨é…ç½®
    }
};
```

### 2. æ€§èƒ½ä¼˜åŒ–æŒ‡å—

```javascript
// hooks/performance-guide.js
/// <reference path="../pb_data/types.d.ts" -->

/**
 * æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹
 */

class PerformanceOptimizer {
    constructor() {
        this.cache = new Map();
        this.batchQueue = [];
        this.batchTimer = null;
    }

    // âœ… ä½¿ç”¨ç¼“å­˜
    async getCachedAnalysis(url) {
        const cacheKey = this.hash(url);
        const cached = this.cache.get(cacheKey);

        if (cached && this.isCacheValid(cached)) {
            return cached.data;
        }

        const analysis = await this.performAnalysis(url);
        this.setCache(cacheKey, analysis);
        return analysis;
    }

    // âœ… æ‰¹å¤„ç†
    batchProcess(items) {
        return new Promise((resolve) => {
            this.batchQueue.push(...items);

            if (this.batchTimer) {
                clearTimeout(this.batchTimer);
            }

            this.batchTimer = setTimeout(() => {
                const batch = this.batchQueue.splice(0);
                const results = this.processBatch(batch);
                resolve(results);
            }, 100);
        });
    }

    // âœ… å¼‚æ­¥å¤„ç†éå…³é”®ä»»åŠ¡
    async handleURL(url) {
        // åŒæ­¥å¤„ç†æ ¸å¿ƒé€»è¾‘
        const category = this.categorizeURL(url);

        // å¼‚æ­¥å¤„ç†è€—æ—¶ä»»åŠ¡
        setImmediate(() => {
            this.fetchMetadata(url);
            this.generateThumbnail(url);
            this.updateStatistics(url);
        });

        return { category };
    }

    // âœ… æ•°æ®åº“ä¼˜åŒ–
    async getUserURLs(userId, page = 1, limit = 20) {
        const offset = (page - 1) * limit;

        // ä½¿ç”¨ç´¢å¼•å‹å¥½çš„æŸ¥è¯¢
        return app.db.query(`
            SELECT id, url, title, category, created_at
            FROM urls
            WHERE user_id = ? AND deleted_at IS NULL
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        `, [userId, limit, offset]);
    }

    // âœ… è¿æ¥æ± ç®¡ç†
    async batchInsert(urls) {
        const stmt = app.db.prepare(`
            INSERT INTO urls (id, url, user_id, created_at)
            VALUES (?, ?, ?, datetime('now'))
        `);

        try {
            app.db.transaction(() => {
                urls.forEach(url => {
                    stmt.run([this.generateId(), url.url, url.userId]);
                });
            });
        } finally {
            stmt.finalize();
        }
    }

    // å·¥å…·æ–¹æ³•
    hash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return hash.toString(36);
    }

    isCacheValid(cached) {
        return Date.now() - cached.timestamp < 5 * 60 * 1000;
    }

    setCache(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });

        // é™åˆ¶ç¼“å­˜å¤§å°
        if (this.cache.size > 1000) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
    }
}
```

### 3. å®‰å…¨æœ€ä½³å®è·µ

```javascript
// hooks/security-guide.js
/// <reference path="../pb_data/types.d.ts" />

/**
 * å®‰å…¨æœ€ä½³å®è·µç¤ºä¾‹
 */

class SecurityManager {
    constructor() {
        this.allowedDomains = this.loadAllowedDomains();
        this.rateLimits = new Map();
    }

    // âœ… è¾“å…¥éªŒè¯
    validateURL(url) {
        if (!url || typeof url !== 'string') {
            throw new Error('URLä¸èƒ½ä¸ºç©º');
        }

        try {
            const urlObj = new URL(url);

            // åªå…è®¸HTTPå’ŒHTTPSåè®®
            if (!['http:', 'https:'].includes(urlObj.protocol)) {
                throw new Error('åªæ”¯æŒHTTPå’ŒHTTPSåè®®');
            }

            // æ£€æŸ¥åŸŸåç™½åå•
            if (!this.isDomainAllowed(urlObj.hostname)) {
                throw new Error('åŸŸåä¸åœ¨å…è®¸åˆ—è¡¨ä¸­');
            }

            // é™åˆ¶URLé•¿åº¦
            if (url.length > 2048) {
                throw new Error('URLé•¿åº¦è¶…è¿‡é™åˆ¶');
            }

            return true;
        } catch (error) {
            throw new Error(`URLæ ¼å¼æ— æ•ˆ: ${error.message}`);
        }
    }

    // âœ… SQLæ³¨å…¥é˜²æŠ¤
    findUserByURL(userId, url) {
        // ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
        return app.db.queryOne(`
            SELECT * FROM urls
            WHERE user_id = ? AND url = ? AND deleted_at IS NULL
        `, [userId, url]);
    }

    // âœ… XSSé˜²æŠ¤
    sanitizeHTML(html) {
        // ç§»é™¤æ½œåœ¨çš„å±é™©HTML
        return html
            .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
            .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
            .replace(/javascript:/gi, '')
            .replace(/on\w+\s*=/gi, '');
    }

    // âœ… é™æµ
    checkRateLimit(clientId, limit = 100, window = 60000) {
        const now = Date.now();
        const clientData = this.rateLimits.get(clientId) || { count: 0, resetTime: now + window };

        if (now > clientData.resetTime) {
            clientData.count = 0;
            clientData.resetTime = now + window;
        }

        if (clientData.count >= limit) {
            throw new Error('è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•');
        }

        clientData.count++;
        this.rateLimits.set(clientId, clientData);
    }

    // âœ… æƒé™æ£€æŸ¥
    checkURLAccess(userId, urlId) {
        const url = app.db.queryOne(`
            SELECT user_id FROM urls WHERE id = ? AND deleted_at IS NULL
        `, [urlId]);

        if (!url) {
            throw new Error('URLä¸å­˜åœ¨');
        }

        if (url.user_id !== userId) {
            throw new Error('æ— æƒè®¿é—®æ­¤URL');
        }

        return true;
    }

    // âœ… æ•æ„Ÿæ•°æ®å¤„ç†
    maskEmail(email) {
        const [username, domain] = email.split('@');
        const maskedUsername = username.slice(0, 2) + '*'.repeat(username.length - 2);
        return `${maskedUsername}@${domain}`;
    }

    // å·¥å…·æ–¹æ³•
    loadAllowedDomains() {
        try {
            const result = app.db.query('SELECT domain FROM allowed_domains');
            return new Set(result.map(row => row.domain));
        } catch {
            return new Set(['github.com', 'stackoverflow.com', 'youtube.com']);
        }
    }

    isDomainAllowed(domain) {
        return this.allowedDomains.has(domain) ||
               Array.from(this.allowedDomains).some(allowed =>
                   domain.endsWith(allowed)
               );
    }
}

// å®‰å…¨ä¸­é—´ä»¶ç¤ºä¾‹
function securityMiddleware(handler) {
    return async (e) => {
        const security = new SecurityManager();
        const clientId = e.headers['x-client-id'] || e.ip || 'anonymous';

        try {
            // é™æµæ£€æŸ¥
            security.checkRateLimit(clientId);

            // æƒé™æ£€æŸ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if (e.pathParams.id) {
                security.checkURLAccess(e.user?.id, e.pathParams.id);
            }

            return await handler(e);
        } catch (error) {
            // è®°å½•å®‰å…¨äº‹ä»¶
            app.db.execute(`
                INSERT INTO security_events (
                    client_id, event_type, message, path, created_at
                ) VALUES (?, ?, ?, ?, datetime('now'))
            `, [clientId, 'security_violation', error.message, e.path]);

            return e.json(403, {
                error: 'è®¿é—®è¢«æ‹’ç»',
                message: error.message
            });
        }
    };
}
```

è¿™ä¸ªæ’ä»¶å¼€å‘æŒ‡å—æä¾›äº†ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§å®è·µçš„å®Œæ•´æŒ‡å¯¼ï¼Œå¸®åŠ©å¼€å‘è€…åˆ›å»ºé«˜è´¨é‡ã€å®‰å…¨ã€é«˜æ€§èƒ½çš„URLDBæ’ä»¶ã€‚